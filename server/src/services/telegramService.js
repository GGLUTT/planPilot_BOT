const TelegramBot = require('node-telegram-bot-api');
const User = require('../models/User');
const Task = require('../models/Task');

let bot;

/**
 * Initialize the Telegram bot
 */
const initBot = () => {
  const token = process.env.TELEGRAM_BOT_TOKEN;
  
  if (!token) {
    console.error('TELEGRAM_BOT_TOKEN is required to initialize the bot');
    return null;
  }
  
  // Create bot instance
  bot = new TelegramBot(token, { polling: true });
  
  // Set commands menu
  bot.setMyCommands([
    { command: '/start', description: '–ü–æ—á–∞—Ç–∏ —Ä–æ–±–æ—Ç—É –∑ –±–æ—Ç–æ–º' },
    { command: '/tasks', description: '–ü–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ –≤–∞—à—ñ –∑–∞–≤–¥–∞–Ω–Ω—è' },
    { command: '/today', description: '–ó–∞–≤–¥–∞–Ω–Ω—è –Ω–∞ —Å—å–æ–≥–æ–¥–Ω—ñ' },
    { command: '/connect', description: '–ü—ñ–¥–∫–ª—é—á–∏—Ç–∏ –∞–∫–∞—É–Ω—Ç PlanPilot' },
    { command: '/disconnect', description: '–í—ñ–¥–∫–ª—é—á–∏—Ç–∏ –∞–∫–∞—É–Ω—Ç' },
    { command: '/notifications', description: '–ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Å–ø–æ–≤—ñ—â–µ–Ω—å' },
    { command: '/help', description: '–û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ–ø–æ–º–æ–≥—É' }
  ]);
  
  // Register message handlers
  registerBotHandlers(bot);
  
  return bot;
};

/**
 * Register all message handlers for the bot
 */
const registerBotHandlers = (bot) => {
  // Start command
  bot.onText(/\/start/, async (msg) => {
    const chatId = msg.chat.id;
    const username = msg.from.username;
    
    // Check if user already connected
    const user = await User.findOne({ 'telegram.chatId': chatId });
    
    if (user) {
      bot.sendMessage(chatId, `–í—ñ—Ç–∞—é, ${user.name}! –í–∞—à –∞–∫–∞—É–Ω—Ç –≤–∂–µ –ø—ñ–¥–∫–ª—é—á–µ–Ω–æ –¥–æ PlanPilot. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –∫–æ–º–∞–Ω–¥–∏ –¥–ª—è –∫–µ—Ä—É–≤–∞–Ω–Ω—è –∑–∞–≤–¥–∞–Ω–Ω—è–º–∏.`);
    } else {
      bot.sendMessage(chatId, 
        `–í—ñ—Ç–∞—é! –Ø –±–æ—Ç PlanPilot –¥–ª—è –∫–µ—Ä—É–≤–∞–Ω–Ω—è –∑–∞–≤–¥–∞–Ω–Ω—è–º–∏. ` +
        `–©–æ–± –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏ –≤–∞—à –∞–∫–∞—É–Ω—Ç, –≤–≤–µ–¥—ñ—Ç—å –∫–æ–º–∞–Ω–¥—É /connect —Ç–∞ –∫–æ–¥, —è–∫–∏–π –≤–∏ –æ—Ç—Ä–∏–º–∞—î—Ç–µ –≤ –¥–æ–¥–∞—Ç–∫—É PlanPilot.`
      );
    }
  });
  
  // Help command
  bot.onText(/\/help/, (msg) => {
    const chatId = msg.chat.id;
    
    bot.sendMessage(chatId, 
      `*–ö–æ–º–∞–Ω–¥–∏ PlanPilot –±–æ—Ç–∞:*\n\n` +
      `/start - –ü–æ—á–∞—Ç–∏ —Ä–æ–±–æ—Ç—É –∑ –±–æ—Ç–æ–º\n` +
      `/tasks - –ü–µ—Ä–µ–≥–ª—è–Ω—É—Ç–∏ –≤–∞—à—ñ –∑–∞–≤–¥–∞–Ω–Ω—è\n` +
      `/today - –ó–∞–≤–¥–∞–Ω–Ω—è –Ω–∞ —Å—å–æ–≥–æ–¥–Ω—ñ\n` +
      `/connect - –ü—ñ–¥–∫–ª—é—á–∏—Ç–∏ –∞–∫–∞—É–Ω—Ç PlanPilot\n` +
      `/disconnect - –í—ñ–¥–∫–ª—é—á–∏—Ç–∏ –∞–∫–∞—É–Ω—Ç\n` +
      `/notifications - –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è —Å–ø–æ–≤—ñ—â–µ–Ω—å\n` +
      `/help - –û—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ–ø–æ–º–æ–≥—É`,
      { parse_mode: 'Markdown' }
    );
  });
  
  // Connect command with code
  bot.onText(/\/connect(?:\s+(\d+))?/, async (msg, match) => {
    const chatId = msg.chat.id;
    const username = msg.from.username || '';
    const code = match[1];
    
    // Check if user already connected
    const existingUser = await User.findOne({ 'telegram.chatId': chatId });
    
    if (existingUser) {
      return bot.sendMessage(chatId, `–í–∏ –≤–∂–µ –ø—ñ–¥–∫–ª—é—á–µ–Ω—ñ –¥–æ –∞–∫–∞—É–Ω—Ç—É ${existingUser.name}. –Ø–∫—â–æ —Ö–æ—á–µ—Ç–µ –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏ —ñ–Ω—à–∏–π –∞–∫–∞—É–Ω—Ç, —Å–ø–æ—á–∞—Ç–∫—É –≤—ñ–¥–∫–ª—é—á—ñ—Ç—å –ø–æ—Ç–æ—á–Ω–∏–π –∫–æ–º–∞–Ω–¥–æ—é /disconnect.`);
    }
    
    if (!code) {
      return bot.sendMessage(chatId, '–ë—É–¥—å –ª–∞—Å–∫–∞, –≤–≤–µ–¥—ñ—Ç—å –∫–æ–¥ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è —É —Ñ–æ—Ä–º–∞—Ç—ñ: /connect –ö–û–î\n–ö–æ–¥ –º–æ–∂–Ω–∞ –æ—Ç—Ä–∏–º–∞—Ç–∏ –≤ –¥–æ–¥–∞—Ç–∫—É PlanPilot —É —Ä–æ–∑–¥—ñ–ª—ñ –ø—Ä–æ—Ñ—ñ–ª—é.');
    }
    
    try {
      // Find user by connection code
      const user = await User.findOne({ 
        'telegram.connectionCode': code,
        'telegram.codeExpires': { $gt: new Date() }
      });
      
      if (!user) {
        return bot.sendMessage(chatId, '–ù–µ–≤—ñ—Ä–Ω–∏–π –∞–±–æ –∑–∞—Å—Ç–∞—Ä—ñ–ª–∏–π –∫–æ–¥ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è. –ë—É–¥—å –ª–∞—Å–∫–∞, –∑–≥–µ–Ω–µ—Ä—É–π—Ç–µ –Ω–æ–≤–∏–π –∫–æ–¥ —É –¥–æ–¥–∞—Ç–∫—É PlanPilot.');
      }
      
      // Connect user
      user.telegram.chatId = chatId.toString();
      user.telegram.username = username;
      user.telegram.isConnected = true;
      user.telegram.connectionCode = null;
      user.telegram.codeExpires = null;
      await user.save();
      
      bot.sendMessage(chatId, `–ê–∫–∞—É–Ω—Ç —É—Å–ø—ñ—à–Ω–æ –ø—ñ–¥–∫–ª—é—á–µ–Ω–æ! –í—ñ—Ç–∞—î–º–æ, ${user.name}.\n–¢–µ–ø–µ—Ä –≤–∏ –º–æ–∂–µ—Ç–µ –∫–µ—Ä—É–≤–∞—Ç–∏ –≤–∞—à–∏–º–∏ –∑–∞–≤–¥–∞–Ω–Ω—è–º–∏ —á–µ—Ä–µ–∑ Telegram.`);
    } catch (error) {
      console.error('Error connecting Telegram account:', error);
      bot.sendMessage(chatId, '–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—ñ –∞–∫–∞—É–Ω—Ç—É. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ.');
    }
  });
  
  // Disconnect command
  bot.onText(/\/disconnect/, async (msg) => {
    const chatId = msg.chat.id;
    
    try {
      // Find user by chatId
      const user = await User.findOne({ 'telegram.chatId': chatId });
      
      if (!user) {
        return bot.sendMessage(chatId, '–í–∏ –Ω–µ –ø—ñ–¥–∫–ª—é—á–µ–Ω—ñ –¥–æ –∂–æ–¥–Ω–æ–≥–æ –∞–∫–∞—É–Ω—Ç—É PlanPilot.');
      }
      
      // Disconnect user
      user.telegram.chatId = null;
      user.telegram.username = null;
      user.telegram.isConnected = false;
      await user.save();
      
      bot.sendMessage(chatId, '–ê–∫–∞—É–Ω—Ç —É—Å–ø—ñ—à–Ω–æ –≤—ñ–¥–∫–ª—é—á–µ–Ω–æ. –í–∏ –±—ñ–ª—å—à–µ –Ω–µ –±—É–¥–µ—Ç–µ –æ—Ç—Ä–∏–º—É–≤–∞—Ç–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è.');
    } catch (error) {
      console.error('Error disconnecting Telegram account:', error);
      bot.sendMessage(chatId, '–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –≤—ñ–¥–∫–ª—é—á–µ–Ω–Ω—ñ –∞–∫–∞—É–Ω—Ç—É. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ.');
    }
  });
  
  // Tasks command
  bot.onText(/\/tasks/, async (msg) => {
    const chatId = msg.chat.id;
    
    try {
      // Find user by chatId
      const user = await User.findOne({ 'telegram.chatId': chatId });
      
      if (!user) {
        return bot.sendMessage(chatId, '–°–ø–æ—á–∞—Ç–∫—É –ø—ñ–¥–∫–ª—é—á—ñ—Ç—å –≤–∞—à –∞–∫–∞—É–Ω—Ç PlanPilot –∫–æ–º–∞–Ω–¥–æ—é /connect.');
      }
      
      // Get user's tasks
      const tasks = await Task.find({ user: user._id }).sort({ priority: -1 });
      
      if (tasks.length === 0) {
        return bot.sendMessage(chatId, '–£ –≤–∞—Å –Ω–µ–º–∞—î –∞–∫—Ç–∏–≤–Ω–∏—Ö –∑–∞–≤–¥–∞–Ω—å.');
      }
      
      // Format tasks message
      let tasksMsg = '*–í–∞—à—ñ –∑–∞–≤–¥–∞–Ω–Ω—è:*\n\n';
      
      tasks.forEach((task, index) => {
        const prioritySymbol = task.priority === 'high' ? 'üî¥' : (task.priority === 'medium' ? 'üü†' : 'üü¢');
        const statusSymbol = task.status === 'completed' ? '‚úÖ' : (task.status === 'in-progress' ? '‚è≥' : '‚è∞');
        
        tasksMsg += `${index + 1}. ${statusSymbol} ${prioritySymbol} *${task.title}*\n`;
        if (task.description) {
          tasksMsg += `   ${task.description.substring(0, 50)}${task.description.length > 50 ? '...' : ''}\n`;
        }
        tasksMsg += `   –ö–∞—Ç–µ–≥–æ—Ä—ñ—è: ${task.category}\n\n`;
      });
      
      bot.sendMessage(chatId, tasksMsg, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('Error getting tasks:', error);
      bot.sendMessage(chatId, '–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ –∑–∞–≤–¥–∞–Ω—å. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ.');
    }
  });
  
  // Today's tasks
  bot.onText(/\/today/, async (msg) => {
    const chatId = msg.chat.id;
    
    try {
      // Find user by chatId
      const user = await User.findOne({ 'telegram.chatId': chatId });
      
      if (!user) {
        return bot.sendMessage(chatId, '–°–ø–æ—á–∞—Ç–∫—É –ø—ñ–¥–∫–ª—é—á—ñ—Ç—å –≤–∞—à –∞–∫–∞—É–Ω—Ç PlanPilot –∫–æ–º–∞–Ω–¥–æ—é /connect.');
      }
      
      // Get today's start and end
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      // Get user's tasks for today
      const tasks = await Task.find({
        user: user._id,
        $or: [
          { dueDate: { $gte: today, $lt: tomorrow } },
          { status: 'in-progress' }
        ]
      }).sort({ priority: -1 });
      
      if (tasks.length === 0) {
        return bot.sendMessage(chatId, '–£ –≤–∞—Å –Ω–µ–º–∞—î –∑–∞–≤–¥–∞–Ω—å –Ω–∞ —Å—å–æ–≥–æ–¥–Ω—ñ.');
      }
      
      // Format tasks message
      let tasksMsg = '*–ó–∞–≤–¥–∞–Ω–Ω—è –Ω–∞ —Å—å–æ–≥–æ–¥–Ω—ñ:*\n\n';
      
      tasks.forEach((task, index) => {
        const prioritySymbol = task.priority === 'high' ? 'üî¥' : (task.priority === 'medium' ? 'üü†' : 'üü¢');
        const statusSymbol = task.status === 'completed' ? '‚úÖ' : (task.status === 'in-progress' ? '‚è≥' : '‚è∞');
        
        tasksMsg += `${index + 1}. ${statusSymbol} ${prioritySymbol} *${task.title}*\n`;
        tasksMsg += `   –ö–∞—Ç–µ–≥–æ—Ä—ñ—è: ${task.category}\n\n`;
      });
      
      bot.sendMessage(chatId, tasksMsg, { parse_mode: 'Markdown' });
    } catch (error) {
      console.error('Error getting today tasks:', error);
      bot.sendMessage(chatId, '–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –æ—Ç—Ä–∏–º–∞–Ω–Ω—ñ –∑–∞–≤–¥–∞–Ω—å. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ.');
    }
  });
  
  // Toggle notifications
  bot.onText(/\/notifications/, async (msg) => {
    const chatId = msg.chat.id;
    
    try {
      // Find user by chatId
      const user = await User.findOne({ 'telegram.chatId': chatId });
      
      if (!user) {
        return bot.sendMessage(chatId, '–°–ø–æ—á–∞—Ç–∫—É –ø—ñ–¥–∫–ª—é—á—ñ—Ç—å –≤–∞—à –∞–∫–∞—É–Ω—Ç PlanPilot –∫–æ–º–∞–Ω–¥–æ—é /connect.');
      }
      
      // Toggle notifications
      user.telegram.notificationsEnabled = !user.telegram.notificationsEnabled;
      await user.save();
      
      const status = user.telegram.notificationsEnabled ? '—É–≤—ñ–º–∫–Ω–µ–Ω–æ' : '–≤–∏–º–∫–Ω–µ–Ω–æ';
      bot.sendMessage(chatId, `–°–ø–æ–≤—ñ—â–µ–Ω–Ω—è ${status}. ${user.telegram.notificationsEnabled ? '–í–∏ –±—É–¥–µ—Ç–µ –æ—Ç—Ä–∏–º—É–≤–∞—Ç–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –ø—Ä–æ –∑–∞–≤–¥–∞–Ω–Ω—è.' : '–í–∏ –Ω–µ –±—É–¥–µ—Ç–µ –æ—Ç—Ä–∏–º—É–≤–∞—Ç–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è.'}`);
    } catch (error) {
      console.error('Error toggling notifications:', error);
      bot.sendMessage(chatId, '–°—Ç–∞–ª–∞—Å—è –ø–æ–º–∏–ª–∫–∞ –ø—Ä–∏ –∑–º—ñ–Ω—ñ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω—å —Å–ø–æ–≤—ñ—â–µ–Ω—å. –°–ø—Ä–æ–±—É–π—Ç–µ –ø—ñ–∑–Ω—ñ—à–µ.');
    }
  });
  
  // Handle unknown commands
  bot.on('message', (msg) => {
    // Skip messages that were handled by other handlers
    if (msg.text && msg.text.startsWith('/')) {
      const command = msg.text.split(' ')[0];
      const knownCommands = ['/start', '/help', '/connect', '/disconnect', '/tasks', '/today', '/notifications'];
      
      if (!knownCommands.includes(command)) {
        bot.sendMessage(msg.chat.id, `–ù–µ–≤—ñ–¥–æ–º–∞ –∫–æ–º–∞–Ω–¥–∞: ${command}. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ /help –¥–ª—è –ø–µ—Ä–µ–≥–ª—è–¥—É –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –∫–æ–º–∞–Ω–¥.`);
      }
    }
  });
};

/**
 * Send a task notification to a user
 */
const sendTaskNotification = async (userId, message) => {
  if (!bot) {
    console.error('Telegram bot not initialized');
    return false;
  }
  
  try {
    // Find user
    const user = await User.findById(userId);
    
    if (!user || !user.telegram.isConnected || !user.telegram.notificationsEnabled) {
      return false;
    }
    
    // Send notification
    await bot.sendMessage(user.telegram.chatId, message, { parse_mode: 'Markdown' });
    return true;
  } catch (error) {
    console.error('Error sending Telegram notification:', error);
    return false;
  }
};

/**
 * Send a reminder for a task
 */
const sendTaskReminder = async (task) => {
  if (!task.user || !task.user.telegram || !task.user.telegram.chatId) {
    return false;
  }
  
  try {
    const prioritySymbol = task.priority === 'high' ? 'üî¥' : (task.priority === 'medium' ? 'üü†' : 'üü¢');
    
    const message = `*–ù–∞–≥–∞–¥—É–≤–∞–Ω–Ω—è –ø—Ä–æ –∑–∞–≤–¥–∞–Ω–Ω—è*\n\n` +
      `${prioritySymbol} *${task.title}*\n` +
      `–ö–∞—Ç–µ–≥–æ—Ä—ñ—è: ${task.category}\n` +
      `${task.description ? `–û–ø–∏—Å: ${task.description}\n` : ''}`;
    
    await bot.sendMessage(task.user.telegram.chatId, message, { parse_mode: 'Markdown' });
    
    // Mark reminder as sent
    task.reminderSent = true;
    await task.save();
    
    return true;
  } catch (error) {
    console.error('Error sending task reminder:', error);
    return false;
  }
};

/**
 * Process due task reminders
 */
const processDueTaskReminders = async () => {
  try {
    const dueTasks = await Task.findDueTasksForReminders();
    
    for (const task of dueTasks) {
      await sendTaskReminder(task);
    }
    
    return dueTasks.length;
  } catch (error) {
    console.error('Error processing due tasks:', error);
    return 0;
  }
};

module.exports = {
  initBot,
  sendTaskNotification,
  sendTaskReminder,
  processDueTaskReminders,
  getBot: () => bot
}; 